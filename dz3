# Написать функцию num_translate(), переводящую числительные от 0 до 10 c английского на
# русский язык. Например:
# >>> num_translate("one")
# "один"
# >>> num_translate("eight")
# "восемь"
# Если перевод сделать невозможно, вернуть None. Подумайте, как и где лучше хранить
# информацию, необходимую для перевода: какой тип данных выбрать, в теле функции или
# снаружи.

# def num_translate(arg):
#     number = {
#         "zero": 'ноль',
#         "one": 'один',
#         "two": 'два',
#         "three": 'три',
#         "four": 'четыре',
#         "five": 'пять',
#         "six": 'шесть',
#         "seven": 'семь',
#         "eight": 'восемь',
#         "nine": 'девять',
#         "ten": 'десять',
#     }
#     print(number.get(arg))
# num_translate("zerof")
# *(вместо задачи 1) Доработать предыдущую функцию в num_translate_adv(): реализовать
# корректную работу с числительными, начинающимися с заглавной буквы — результат тоже
# должен быть с заглавной. Например:
# >>> num_translate_adv("One")
# "Один"
# # >>> num_translate_adv("two")
# # "два"
# def num_translate_adv(arg):
#     number = {
#         "zero": 'ноль',
#         "one": 'один',
#         "two": 'два',
#         "three": 'три',
#         "four": 'четыре',
#         "five": 'пять',
#         "six": 'шесть',
#         "seven": 'семь',
#         "eight": 'восемь',
#         "nine": 'девять',
#         "ten": 'десять',
#     }
#     if arg.istitle() == True and number.get(arg.lower()) != None:
#         arg = arg.lower()
#         print(str.title(number.get(arg)))
#     else:
#         print(number.get(arg))
# num_translate_adv("Zero")


# Написать функцию thesaurus(), принимающую в качестве аргументов имена сотрудников и возвращающую
# словарь, в котором ключи — первые буквы имён, а значения — списки, содержащие имена, начинающиеся
# с соответствующей буквы. Например:
# >>> thesaurus("Иван", "Мария", "Петр", "Илья")
# {
#     "И": ["Иван", "Илья"],
#     "М": ["Мария"],
#     "П": ["Петр"]
# }
#
#
# Подумайте: полезен ли будет вам оператор распаковки? Как поступить, если потребуется сортировка
# по ключам? Можно ли использовать словарь в этом случае?
#
# def thesaurus(*args):
#     names = dict()
#     for i in args:
#         if names.get(i[0]) == None:
#             names[i[0]] = [i]
#         else:
#             names[i[0]].append(i)
#     for k, v in names.items():
#         print(k, v)
# thesaurus("Иван", "Мария", "Петр", "Илья",)

# 5. Реализовать функцию get_jokes(), возвращающую n шуток, сформированных из трех случайных слов,
# взятых из трёх списков (по одному из каждого):
# nouns = ["автомобиль", "лес", "огонь", "город", "дом"]
# adverbs = ["сегодня", "вчера", "завтра", "позавчера", "ночью"]
# adjectives = ["веселый", "яркий", "зеленый", "утопичный", "мягкий"]
#         Например:
# >>> get_jokes(2)
# ["лес завтра зеленый", "город вчера веселый"]
# Документировать код функции.
# Сможете ли вы добавить еще один аргумент — флаг, разрешающий или запрещающий повторы слов в шутках
# (когда каждое слово можно использовать только в одной шутке)? Сможете ли вы сделать аргументы именованными?
# Задачи со * предназначены для продвинутых учеников, которым мало сделать обычное ДЗ.
import random
def  get_jokes(a, flag_replay = 0):
    """
    :param a:  number jok
    :param flag_replay:
    :return:
    """
    b = 1
    nouns = ["автомобиль", "лес", "огонь", "город", "дом"]
    adverbs = ["сегодня", "вчера", "завтра", "позавчера", "ночью"]
    adjectives = ["веселый", "яркий", "зеленый", "утопичный", "мягкий"]
    while b <= a:
        joke = [random.choice(nouns), random.choice(adverbs), random.choice(adjectives)]
        for i in joke:
            print(i, end = ' ')
        b += 1
        print()
        if flag_replay == 1:
            nouns.remove(joke[0])
            adverbs.remove(joke[1])
            adjectives.remove(joke[2])
get_jokes(5, 1)



